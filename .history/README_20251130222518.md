
## Implementation Details (For Team & Report Reference)

### **Task 1: PNML Parsing Strategy**
* **Library Used:** `xml.etree.ElementTree` (Python Standard Library).
* **Logic:**
    1. The parser reads the XML tree structure.
    2. It extracts `Places` and identifies the `initialMarking` (token count).
    3. It extracts `Transitions` and `Arcs`.
    4. **Consistency Check:** During parsing, the code validates that every arc connects to a valid existing Source (Place/Transition) and Target.
* **Data Structures:**
    * `places`: Dictionary `{id: PlaceObj}` for O(1) lookup.
    * `transitions`: Dictionary `{id: TransitionObj}`.
    * `pre_set` / `post_set`: Adjacency lists to store graph connections, allowing fast retrieval of input/output places for any transition during the firing process.

### **Task 2: Explicit Reachability (BFS)**
* **Algorithm:** Breadth-First Search (BFS).
* **State Representation:**
    * A marking is represented as a Python `tuple` of integers (e.g., `(1, 0, 1)`), corresponding to token counts of places sorted by ID.
    * Using `tuple` allows markings to be hashed and stored in a `set`.
* **Process:**
    1. Start with `M0` (Initial Marking).
    2. In each step, identify **enabled transitions** (where all input places have token > 0).
    3. **Fire transition:** Create a new marking by strictly subtracting tokens from inputs and adding to outputs (handling the 1-safe property naturally).
    4. **Loop Detection:** Before adding a new marking to the Queue, check if it exists in the `visited` set. This prevents infinite loops in cyclic nets.

### **Task 4: Deadlock Detection (ILP & BDD)**

* **GOAL:** Detect if a "Deadlock" exists (a reachable state where no transition can fire).

* **Logic (Symbolic Constraints):** Instead of using an external ILP solver, we formulate the constraints using Boolean Logic (which is equivalent for 1-safe nets):

    1. **Transition Disabled Condition:** A transition $t$ is disabled if at least one input place is empty.

    $$Disabled(t) = \bigvee_{p \in \bullet t} \neg p$$

    2. **Dead State Condition:** The system is dead if all transitions are disabled simultaneously.

    $$Dead = \bigwedge_{t \in T} Disabled(t)$$

    3. **Deadlock Definition:** A deadlock must be a valid reachable state.

    $$Deadlock = Reachable \land Dead$$

* **Implementation:**

    * The function `check_deadlock_bdd(bdd, visited_bdd)` reuses the BDD manager from Task 3.

    * It constructs the `dead_logic` formula by iterating through all transitions.

    * It computes the intersection: `deadlock_set = visited_bdd & dead_logic`.

    * If `deadlock_set` is not `False`, a counter-example marking is extracted and reported.